# Finger 插件实施计划 (基础阶段)

本计划专注于构建插件的核心骨架和最基础的指纹识别功能。

## 第一阶段：环境搭建与骨架构建

### 1.1 初始化 Maven 项目
- **指令**: 创建标准 Maven 目录结构，配置 `pom.xml`，引入 `burp-montoya-api` 依赖。
- **验证**: 运行 `mvn clean compile`，确保无报错且能够成功下载依赖。

### 1.2 插件入口类实现
- **指令**: 创建继承自 `BurpExtension` 的入口类，实现简单的日志输出逻辑（在插件加载时输出 "Finger Plugin Loaded"）。
- **验证**: 将生成的 JAR 包加载到 Burp Suite 中，在 "Extensions" -> "Installed" 的 "Output" 标签页中看到预期的日志信息。

## 第二阶段：模块化规则加载系统

### 2.1 规则数据结构定义
- **指令**: 根据设计文档定义指纹规则的 Java POJO 类（对应 JSON 格式）。
- **验证**: 编写单元测试，模拟一段 JSON 字符串，确保能通过 `Jackson` 正确反序列化为 Java 对象。

### 2.2 模块化加载逻辑
- **指令**: 实现规则加载器，递归扫描 `resources/fingerprints/` 目录下的所有子目录和 `.json` 文件。
- **验证**: 在 `resources` 下创建两个不同子目录的测试 JSON，运行加载器，确认最终合并后的指纹列表总数正确。

## 第三阶段：核心匹配引擎 (被动识别基础)

### 3.1 响应报文处理器
- **指令**: 注册 Montoya API 的 `ProxyResponseHandler`，捕获经过代理的响应。
- **验证**: 在处理器中打印捕获到的每个请求的 URL，通过浏览器访问任意网页，确认 Burp 控制台输出了对应的 URL。

### 3.2 基础 Header/Body 匹配
- **指令**: 实现最基础的字符串包含匹配逻辑（非正则），遍历加载好的规则，匹配响应头或响应体。
- **验证**: 构造一个包含特征字符串（如 `rememberMe=`）的模拟响应，调用匹配方法，确认能准确识别出对应的指纹名称。

## 第四阶段：结果展示 UI (最小化版本)

### 4.1 基础表格视图
- **指令**: 使用 Java Swing 创建一个包含 `URL`, `Fingerprint`, `Type` 三列的简单表格，并将其作为插件的独立 Tab 页添加。
- **验证**: 加载插件后，Burp 顶部导航栏出现 "Finger" 标签页，点击能看到空的表格。

### 4.2 匹配结果实时上屏
- **指令**: 将匹配引擎识别到的结果动态添加到 Swing 表格中。
- **验证**: 使用浏览器访问一个已知特征的站点（如 Spring Boot 报错页面），观察 "Finger" 表格中是否自动新增了一行识别记录。

---

## 质量保证原则 (QA)
- **原子性**: 只有当前步骤通过验证后，才能进入下一步。
- **日志先行**: 每一步关键逻辑必须包含 `Logging` 输出，方便排查故障。
- **隔离性**: 规则加载逻辑必须与匹配逻辑完全隔离，方便后期扩展主动扫描功能。
